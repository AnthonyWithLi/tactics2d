from typing import Tuple
import json

import pandas as pd

from tactics2d.participant.element.participant_base import ParticipantBase
from tactics2d.participant.element.vehicle import Vehicle
from tactics2d.participant.element.pedestrian import Pedestrian
from tactics2d.trajectory.element.state import State
from tactics2d.trajectory.element.trajectory import Trajectory


TYPE_MAPPING = {
    "Car": "medium_car",
    "Medium Vehicle": "medium_car",
    "Bus": "bus",
    "Pedestrian": "pedestrian/male",
    "Undefined": "other",
}

CLASS_MAPPING = {
    "Car": Vehicle,
    "Medium Vehicle": Vehicle,
    "Bus": Vehicle,
    "Pedestrian": Pedestrian,
    "Undefined": ParticipantBase,
}


class DLPParser(object):
    """
    This class implements a parser of the Dragon Lake Parking Dataset.
    
    Shen, Xu, et al. "Parkpredict: Motion and intent prediction of vehicles in parking lots." 2020 IEEE Intelligent Vehicles Symposium (IV). IEEE, 2020.
    """

    def _generate_participant(self, instance, id_):
        type_ = TYPE_MAPPING[instance["type"]]
        class_ = CLASS_MAPPING[instance["type"]]
        if self.processed:
            participant = class_(
                id_=id_, type_=type_,
                length=instance["size"][0], width=instance["size"][1],
                trajectory=Trajectory(id_=id_)
            )
        else:
            participant = class_(
                id_=id_, type_=type_,
                length=instance["length"], width=instance["width"],
                trajectory=Trajectory(id_=id_)
            )

        return participant

    def _parse_unprocessed(self):
        """The subparser for the raw DLP data.
        """

        with open("%s/DJI_%04d_agents.json", "r") as f_agent:
            df_agent = json.load(f_agent)
        with open("%s/DJI_%04d_frames.json", "r") as f_frame:
            df_frame = json.load(f_frame)
        with open("%s/DJI_%04d_instances.json", "r") as f_instance:
            df_instance = json.load(f_instance)
        with open("%s/DJI_%04d_obstacles.json", "r") as f_obstacle:
            df_obstacle = json.load(f_obstacle)

        participants = {}
        id_cnt = 0

        for frame in df_frame.values():
            if frame["timestamp"] < self.stamp_range[0] or frame["timestamp"] > self.stamp_range[1]:
                continue

            for obstacle in df_obstacle.values():
                state = State(frame=int(frame["timestamp"] * 1000))

                if obstacle["obstacle_token"] not in participants:
                    participants[obstacle["obstacle_token"]] = \
                        self._generate_participant(obstacle, id_cnt)
                    id_cnt += 1

                participants[obstacle["obstacle_token"]].trajectory.append(state)

            for instance_token in frame["instances"]:
                instance = df_instance[instance_token]
                state = State(
                    frame=int(frame["timestamp"] * 1000), 
                    x=instance["coords"][0], y=instance["coords"][1], heading=instance["heading"],
                    ax=instance["acceleration"], ay=instance["acceleration"]
                )
                state.set_speed(instance["speed"])

                if instance["agent_token"] not in participants:
                    participants[instance["agent_token"]] = \
                        self._generate_participant(df_agent[instance["agent_token"]], id_cnt)
                    id_cnt += 1
    
                participants[instance["agent_token"]].trajectory.append_state(state)

        return participants

    def _parse_processed(self):
        """The subparser for the processed DLP data generated by tactics2d.utils.preprocess.DLPPreprocess.
        """

        df_participant = pd.read_csv("%s/%04d_tracks.csv" % (self.folder_path, self.file_id))

        stamp_range = (self.stamp_range[0] * 1000, self.stamp_range[0] * 1000)
        participants = {}

        for line in df_participant.iterrows():
            instance = line[0]
            if instance["timeStamp"] < stamp_range[0] or instance["timeStamp"] > stamp_range[1]:
                continue

            if instance["trackId"] not in participants:
                participants[instance["trackId"]] = \
                    self._generate_participant(instance, instance["trackId"])

            state = State(
                frame=instance["frame"], x=instance["xCenter"], y=instance["yCenter"],
                heading=instance["heading"]
            )
            if instance["mode"] != "obstacle":
                state.set_speed(instance["speed"])
                state.set_accel(instance["xAccel"], instance["yAccel"])

            participants[instance["trackId"]].trajectory.append_state(state)

        return participants

    def parse(
            self, file_id: int, folder_path: str, stamp_range: Tuple[float, float] = None,
            processed: bool = True
        ):
        """_summary_

        Args:
            file_id (int): _description_
            folder_path (str): _description_
            stamp_range (Tuple[float, float], optional): _description_. Defaults to None.
            processed (bool, optional): _description_. Defaults to True.
        """

        self.file_id = file_id
        self.folder_path = folder_path

        if any(stamp_range) < 0:
            raise ValueError("The stamp range should be positive.")
        self.stamp_range = stamp_range

        self.processed = processed
        participants = self._parse_processed() if self.processed else self._parse_unprocessed()

        return participants
